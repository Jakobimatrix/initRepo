# .environment_windows
# Sets the needed variables for the .build.sh script


##
# @brief Convert path to Windows format and ensure proper quoting
# @param $1 The path to convert
# @return The converted path
#
convertPath() {
    local path="$1"
    # First, convert to Windows path if cygpath is available
    if command -v cygpath >/dev/null 2>&1; then
        path=$(cygpath -w "$path" 2>/dev/null || echo "$path")
    else
        # Manual conversion if cygpath not available
        path="${path//\//\\}"  # Replace forward slashes with backslashes
        # Add drive letter if missing
        if [[ "$path" =~ ^\\[^\\] ]]; then
            path="C:$path"
        fi
    fi
    # Ensure proper quoting if path contains spaces
    if [[ "$path" == *" "* ]]; then
        path="\"$path\""
    fi
    echo "$path"
}

##
# @brief Search for visual studio path
function vswhere() {
    local vswhere_path="" vs_base=""

    # --- find vswhere.exe ---
    echo "[DEBUG] Searching for vswhere.exe..."
    # First check chocolatey location (common in CI)
    if [[ -f "/c/ProgramData/Chocolatey/bin/vswhere.exe" ]]; then
        vswhere_path="/c/ProgramData/Chocolatey/bin/vswhere.exe"
    else
        # Try common locations
        for p in \
            "C:/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe" \
            "C:/Program Files/Microsoft Visual Studio/Installer/vswhere.exe" \
            "$(command -v vswhere.exe 2>/dev/null)"
        do
            [[ -f "$p" ]] && vswhere_path="$p" && break
        done
    fi
    
    if [[ -z "$vswhere_path" || ! -f "$vswhere_path" ]]; then
        echo "Error: vswhere.exe not found on PATH or in common locations."
        return 1
    fi

    # --- get installation path ---
    echo "[DEBUG] Running vswhere from: $vswhere_path"
    # Run vswhere directly to avoid PowerShell complexities
    local vswhere_out
    vswhere_out=$("$vswhere_path" -latest -products '*' -requires Microsoft.Component.MSBuild -property installationPath)
    echo "[DEBUG] Raw vswhere output:"
    echo "$vswhere_out"
    
    # Take the last non-empty line as the VS path
    vs_base=$(echo "$vswhere_out" | while read -r line; do
        [[ -n "$line" ]] && echo "$line"
    done | tail -1)
    echo "[DEBUG] Extracted VS path: $vs_base"
    
    if [[ -z "$vs_base" ]]; then
        echo "Error: Visual Studio installation not found via vswhere!"
        return 1
    fi
    
    # Convert to proper path format
    vs_base=$(convertPath "$vs_base")
    echo "Found Visual Studio at: $vs_base"

    VS_PATH="$vs_base"
}

vswhere
_vs_rc=$?
if [ "$_vs_rc" -ne 1 ] && [ -n "${VS_PATH:-}" ]; then
    # ok: vswhere did not return 1 and VS_PATH is set
    :
else
    echo "Error: vswhere failed (exit=$_vs_rc) or VS_PATH is not set." >&2
    return 1 2>/dev/null || exit 1
fi

# $VS_PATH now contains the path to vs like: C:\Program Files\Microsoft Visual Studio\2022\Enterprise"
# Extract year from VS_PATH
if [[ "$VS_PATH" =~ "2022" ]]; then
    MSVC_VERSION="17.0"
    VISUAL_STUDIO_VERSION="2022"
elif [[ "$VS_PATH" =~ "2019" ]]; then
    MSVC_VERSION="16.0"
    VISUAL_STUDIO_VERSION="2019"
else
    echo "Unsupported Visual Studio version in path: $VS_PATH" >&2
    return 1 2>/dev/null || exit 1
fi

if [[ "1" == "2" ]]; then
    # Find the latest toolset version (folder with numbers and dots containing a bin folder)
    MSVC_TOOLS_PATH="$VS_PATH/VC/Tools/MSVC"
    if [ ! -d "$MSVC_TOOLS_PATH" ]; then
        echo "Error: MSVC tools path not found at $MSVC_TOOLS_PATH" >&2
        return 1 2>/dev/null || exit 1
    fi

    # Find latest version directory (containing only numbers and dots)
    latest_version=""
    latest_version_num=0
    for dir in "$MSVC_TOOLS_PATH"/*; do
        if [ -d "$dir/bin" ] && [[ $(basename "$dir") =~ ^[0-9.]+$ ]]; then
            # Convert version string to comparable number by removing dots
            ver_num=$(echo "$(basename "$dir")" | tr -d '.')
            if [ "$ver_num" -gt "$latest_version_num" ]; then
                latest_version="$(basename "$dir")"
                latest_version_num=$ver_num
            fi
        fi
    done

    if [ -z "$latest_version" ]; then
        echo "Error: No valid MSVC toolset version found in $MSVC_TOOLS_PATH" >&2
        return 1 2>/dev/null || exit 1
    fi

    MSVC_BASE="$MSVC_TOOLS_PATH/$latest_version/bin"

    # Detect host architecture
    if [ -d "$MSVC_BASE/Hostx64" ]; then
        HOST_ARCH="Hostx64"
    elif [ -d "$MSVC_BASE/Hostx86" ]; then
        HOST_ARCH="Hostx86"
    else
        echo "Error: Neither Hostx64 nor Hostx86 directory found in $MSVC_BASE" >&2
        return 1 2>/dev/null || exit 1
    fi

    # Set all paths to cl.exe in their respective architecture folders
    #MSVC_32_CPP_PATH="$MSVC_BASE/$HOST_ARCH/x86/cl.exe"
    #MSVC_32_C_PATH="$MSVC_BASE/$HOST_ARCH/x86/cl.exe"
    #MSVC_CPP_PATH="$MSVC_BASE/$HOST_ARCH/x64/cl.exe"
    #MSVC_C_PATH="$MSVC_BASE/$HOST_ARCH/x64/cl.exe"
fi

