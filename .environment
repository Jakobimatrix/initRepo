# .environment
# This file defines environment variables for compiler versions, paths, and tool versions.

# Detect architecture
ARCH=$(uname -m 2>/dev/null || echo "unknown")
case "$ARCH" in
    x86_64|amd64)
        ARCH_BITS="x64"
        ARCH="amd"
        ;;
    i386|i486|i586|i686)
        ARCH_BITS="x86"
        ARCH="amd"
        ;;
    arm64|aarch64)
        ARCH_BITS="x64"
        ARCH="arm"
        ;;
    armv7l|armv6l)
        ARCH_BITS="x86"
        ARCH="arm"
        ;;
    *)
        ARCH_BITS="unknown"
        ARCH="unknown"
        ;;
esac

# Detect environment
if grep -qi microsoft /proc/version 2>/dev/null; then
    ENVIRONMENT="WSL"
elif [[ "$OSTYPE" == "msys" ]]; then
    ENVIRONMENT="Windows-msys"
elif [[ "$OSTYPE" == "cygwin" ]]; then
    ENVIRONMENT="Windows-cygwin"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    ENVIRONMENT="Linux"
elif [[ "$OSTYPE" == "darwin"* ]]; then
    ENVIRONMENT="macOS"
else
    ENVIRONMENT="Unknown"
fi

# Common compiler versions
GCC_VERSION=13
CLANG_VERSION=19
MSVC_VERSION="2022"

DEFAULT_COMPILER="g++"

# Common tool versions
CLANG_FORMAT_VERSION=19
CLANG_TIDY_VERSION=19

# Set paths based on environment
if [[ "$ENVIRONMENT" == "Windows-msys" ]]; then
    # MSYS2 paths
    MINGW_GCC_BASE="C:/msys64/mingw64/bin"
    MINGW_32_GCC_BASE="C:/msys64/mingw32/bin"
    
    # Compiler paths
    GCC_CPP_PATH="${MINGW_GCC_BASE}/g++.exe"
    GCC_C_PATH="${MINGW_GCC_BASE}/gcc.exe"
    GCC_32_CPP_PATH="${MINGW_32_GCC_BASE}/g++.exe"
    GCC_32_C_PATH="${MINGW_32_GCC_BASE}/gcc.exe"

    CLANG_CPP_PATH="${MINGW_GCC_BASE}/clang++.exe"
    CLANG_C_PATH="${MINGW_GCC_BASE}/clang.exe"
    CLANG_32_CPP_PATH="${MINGW_32_GCC_BASE}/clang++.exe"
    CLANG_32_C_PATH="${MINGW_32_GCC_BASE}/clang.exe"

    # Tool paths
    CLANG_FORMAT_PATH="${MINGW_GCC_BASE}/clang-format.exe"
    CLANG_TIDY_PATH="${MINGW_GCC_BASE}/clang-tidy.exe"


    ##
    # @brief Delete a file safely across platforms.
    # @param $1 The file path to delete.
    #
    # Handles MSYS2, Cygwin, Git-Bash, and POSIX environments.
    #
    deleteFile() {
        local file="$1"
        if [[ -z "$file" || ! -e "$file" ]]; then
            return 0
        fi

        if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
            # Convert to Windows path for native deletion
            local winpath
            winpath=$(cygpath -w "$file" 2>/dev/null)
            if [[ -n "$winpath" ]]; then
                del /f /q "$winpath" >/dev/null 2>&1 || true
                return
            fi
        fi

        # Fallback for Linux, macOS, WSL, etc.
        rm -f "$file" >/dev/null 2>&1 || true
    }

    ##
    # @brief Create a temporary file safely across environments.
    # @param $1 Optional suffix (e.g. ".ps1")
    # @return The temp file path (echoed)
    #
    makeTempFile() {
        local suffix="${1:-}"
        local tmp

        if command -v mktemp >/dev/null 2>&1; then
            if [[ -n "$suffix" ]]; then
                tmp=$(mktemp 2>/dev/null || echo "/tmp/tmp.$$") || tmp="/tmp/tmp.$$"
                mv "$tmp" "${tmp}${suffix}" 2>/dev/null && tmp="${tmp}${suffix}"
            else
                tmp=$(mktemp 2>/dev/null || echo "/tmp/tmp.$$")
            fi
        else
            tmp="/tmp/tmp.$$${suffix}"
        fi

        # Normalize to POSIX path (avoid C:\...) for bash tools
        if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
            tmp=$(cygpath -u "$tmp" 2>/dev/null || echo "$tmp")
        fi

        echo "$tmp"
    }

    ##
    # @brief Run PowerShell or pwsh depending on platform.
    # @param $@ Command and arguments.
    #
    runPowerShell() {
        echo "[DEBUG] Running PowerShell command with args: $*"
        local result=0
        if command -v powershell.exe >/dev/null 2>&1; then
            echo "[DEBUG] Using powershell.exe"
            powershell.exe "$@"
            result=$?
        elif command -v powershell >/dev/null 2>&1; then
            echo "[DEBUG] Using powershell"
            powershell "$@"
            result=$?
        elif command -v pwsh >/dev/null 2>&1; then
            echo "[DEBUG] Using pwsh"
            pwsh "$@"
            result=$?
        else
            echo "Error: No PowerShell executable found." >&2
            return 1
        fi
        echo "[DEBUG] PowerShell command exit code: $result"
        return $result
    }

    ##
    # @brief Convert path to Windows format and ensure proper quoting
    # @param $1 The path to convert
    # @return The converted path
    #
    convertPath() {
        local path="$1"
        # First, convert to Windows path if cygpath is available
        if command -v cygpath >/dev/null 2>&1; then
            path=$(cygpath -w "$path" 2>/dev/null || echo "$path")
        else
            # Manual conversion if cygpath not available
            path="${path//\//\\}"  # Replace forward slashes with backslashes
            # Add drive letter if missing
            if [[ "$path" =~ ^\\[^\\] ]]; then
                path="C:$path"
            fi
        fi
        # Ensure proper quoting if path contains spaces
        if [[ "$path" == *" "* ]]; then
            path="\"$path\""
        fi
        echo "$path"
    }

    ##
    # @brief Run cmd.exe commands safely across environments.
    # @param $@ Command and arguments.
    #
    runCmd() {
        echo "[DEBUG] Running CMD command with args: $*"
        local result=0
        if command -v cmd.exe >/dev/null 2>&1; then
            echo "[DEBUG] Using cmd.exe"
            # /D disables AutoRun, /C executes command and terminates
            cmd.exe /D /C "$@"
            result=$?
        else
            echo "Error: cmd.exe not found." >&2
            return 1
        fi
        echo "[DEBUG] CMD command exit code: $result"
        return $result
    }

    ##
    # @brief Alternative VS environment setup using cmd.exe
    # @param $1 Architecture ("x86" or "x64")
    #
    setup_msvc_env_cmd() {
        local arch_bits="$1"
        local vs_base tmpfile result=0
        
        echo "[DEBUG] Starting MSVC environment setup via CMD for architecture: $arch_bits"
        
        # Find VS installation using vswhere
        vs_base=$(runCmd "\"$(cygpath -w "$(command -v vswhere.exe)")\"" -latest -products '*' -requires Microsoft.Component.MSBuild -property installationPath | tr -d '\r' | tail -n 1)
        if [[ -z "$vs_base" ]]; then
            echo "Error: Could not find Visual Studio installation"
            return 1
        fi
        
        # Create temporary file for environment capture
        tmpfile=$(makeTempFile ".bat")
        
        # Create a batch file that will:
        # 1. Call VsDevCmd.bat
        # 2. Echo environment variables we care about
        local vs_cmd_path
        vs_cmd_path=$(convertPath "${vs_base}/Common7/Tools/VsDevCmd.bat")
        echo "[DEBUG] VS Command path: $vs_cmd_path"
        
        cat > "$tmpfile" <<BATCH
@echo off
echo [BATCH] Setting up Visual Studio environment...
echo [BATCH] Using: $vs_cmd_path
call $vs_cmd_path -arch=$arch_bits -no_logo
if errorlevel 1 (
    echo [BATCH] Error: VsDevCmd.bat failed
    exit /b 1
)
echo [BATCH] Environment setup complete, dumping variables:
echo PATH=%PATH%
echo INCLUDE=%INCLUDE%
echo LIB=%LIB%
echo LIBPATH=%LIBPATH%
BATCH
        
        echo "[DEBUG] Created temporary batch file: $tmpfile"
        echo "[DEBUG] Batch file contents:"
        cat "$tmpfile"
        
        # Execute batch file and capture output
        local envfile
        envfile=$(makeTempFile ".env")
        runCmd "$(cygpath -w "$tmpfile")" > "$envfile"
        result=$?
        
        echo "[DEBUG] Environment setup exit code: $result"
        echo "[DEBUG] Raw environment output:"
        cat "$envfile"
        
        # Parse and export environment variables
        echo "[DEBUG] Processing environment variables..."
        while IFS='=' read -r name value; do
            case "$name" in
                PATH|INCLUDE|LIB|LIBPATH)
                    if [[ "$name" == "PATH" ]]; then
                        # Ensure paths are in MSYS format and properly separated
                        local newpath=""
                        # Split the Windows PATH on semicolons
                        IFS=';' read -ra paths <<< "$value"
                        for p in "${paths[@]}"; do
                            # Skip empty paths
                            [[ -z "$p" ]] && continue
                            # Convert each path to MSYS format
                            if [[ "$p" == *"Visual Studio"* || "$p" == *"Microsoft"* ]]; then
                                local mpath="/$(echo "$p" | sed 's/://' | sed 's/\\/\//g')"
                                [[ -n "$newpath" ]] && newpath="$newpath:"
                                newpath="$newpath$mpath"
                            fi
                        done
                        # Prepend VS paths to existing PATH
                        export PATH="$newpath:$PATH"
                        echo "[DEBUG] Modified PATH with VS paths"
                    else
                        export "$name=$value"
                        echo "[DEBUG] Exported $name=$value"
                    fi
                    ;;
                *)
                    echo "[DEBUG] Skipping variable: $name"
                    ;;
            esac
        done < "$envfile"
        
        echo "[DEBUG] Environment variables processed"
        echo "[DEBUG] Final PATH entries:"
        echo "$PATH" | tr ':' '\n' | grep -i "visual studio"
        
        # Cleanup
        deleteFile "$tmpfile"
        deleteFile "$envfile"
        
        # Verify setup
        if ! command -v cl.exe &>/dev/null; then
            echo "Error: cl.exe not found in PATH after CMD-based setup"
            echo "[DEBUG] Current PATH: $PATH"
            return 1
        fi
        
        echo "MSVC environment loaded successfully via CMD (arch=$arch_bits)"
        return 0
    }

    # Call this as: setup_msvc_env "<x86|x64>"
    function setup_msvc_env() {
        local arch_bits="$1"   # expected "x86" or "x64"
        local vswhere_path="" vs_base=""
        local tmpfile

        echo "[DEBUG] Starting MSVC environment setup for architecture: $arch_bits"
        echo "[DEBUG] Current PATH: $PATH"
        
        # --- find vswhere.exe ---
        echo "[DEBUG] Searching for vswhere.exe..."
        vswhere_path=$(cmd.exe /C "where vswhere.exe" 2>/dev/null | tr -d '\r' || true)
        if [[ -z "$vswhere_path" || ! -f "$vswhere_path" ]]; then
            for p in \
                "C:/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe" \
                "C:/Program Files/Microsoft Visual Studio/Installer/vswhere.exe"
            do
                [[ -f "$p" ]] && vswhere_path="$p" && break
            done
        fi
        if [[ -z "$vswhere_path" || ! -f "$vswhere_path" ]]; then
            echo "Error: vswhere.exe not found on PATH or in common locations."
            return 1
        fi

        # --- get installation path ---
        echo "[DEBUG] Running vswhere from: $vswhere_path"
        # Capture vswhere output in a variable first
        local vswhere_out
        vswhere_out=$(runPowerShell -NoProfile -Command "& { & \"$vswhere_path\" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath }" 2>&1)
        echo "[DEBUG] Raw vswhere output:"
        echo "$vswhere_out"
        
        # Extract the actual path, removing any debug output
        vs_base=$(echo "$vswhere_out" | grep -v '^\[DEBUG\]' | tr -d '\r' | tail -n 1)
        echo "[DEBUG] Extracted VS path: $vs_base"
        
        if [[ -z "$vs_base" ]]; then
            echo "Error: Visual Studio installation not found via vswhere!"
            return 1
        fi
        
        # Convert to proper path format
        vs_base=$(convertPath "$vs_base")
        echo "Found Visual Studio at: $vs_base"

        # --- candidate scripts ---
        local vsdev="${vs_base}/Common7/Tools/VsDevCmd.bat"
        local vcvarsall="${vs_base}/VC/Auxiliary/Build/vcvarsall.bat"
        local vcvars32="${vs_base}/VC/Auxiliary/Build/vcvars32.bat"
        local vcvars64="${vs_base}/VC/Auxiliary/Build/vcvars64.bat"
        local chosen=""

        if [[ -f "$vsdev" ]]; then
            chosen="$vsdev"
            echo "Using VsDevCmd: $chosen"
        elif [[ -f "$vcvarsall" ]]; then
            chosen="$vcvarsall"
            echo "Using vcvarsall: $chosen"
        elif [[ "$arch_bits" == "x86" && -f "$vcvars32" ]]; then
            chosen="$vcvars32"
            echo "Using vcvars32: $chosen"
        elif [[ "$arch_bits" == "x64" && -f "$vcvars64" ]]; then
            chosen="$vcvars64"
            echo "Using vcvars64: $chosen"
        else
            chosen=$(find "$vs_base" -type f -iname "vcvars*.bat" 2>/dev/null | head -n 1 || true)
            [[ -n "$chosen" ]] && echo "Found alternative vcvars script: $chosen"
        fi

        if [[ -z "$chosen" || ! -f "$chosen" ]]; then
            echo "Error: No suitable vcvars/VsDevCmd script found under $vs_base"
            return 1
        fi

        # --- create temp file ---
        tmpfile=$(makeTempFile)

        ## --- run script and dump environment using a temporary PowerShell script ---
        # Write a small .ps1 file so we avoid inline quoting issues and ensure the arch
        # argument is passed as a literal (x86/x64) to the vcvars/VsDevCmd script.
        ps1file=$(makeTempFile ".ps1")
        cat > "$ps1file" <<'PS1'
param(
    [string]$chosen,
    [string]$arch
)

Write-Host "[PS] Starting Visual Studio environment setup..."
Write-Host "[PS] Using script: $chosen"
Write-Host "[PS] Architecture: $arch"

# Try to call the script with explicit architecture
try {
    $processInfo = New-Object System.Diagnostics.ProcessStartInfo
    $processInfo.FileName = "cmd.exe"
    $processInfo.Arguments = "/c `"'$chosen' -arch $arch`""
    $processInfo.RedirectStandardOutput = $true
    $processInfo.RedirectStandardError = $true
    $processInfo.UseShellExecute = $false
    
    Write-Host "[PS] Executing VS environment script..."
    $process = [System.Diagnostics.Process]::Start($processInfo)
    $process.WaitForExit()
    
    $output = $process.StandardOutput.ReadToEnd()
    $error = $process.StandardError.ReadToEnd()
    
    Write-Host "[PS] Script output:"
    Write-Host $output
    if ($error) {
        Write-Host "[PS] Script errors:"
        Write-Host $error
    }
    
    Write-Host "[PS] Script exit code: " + $process.ExitCode
} catch {
    Write-Host "[PS] Error executing VS script: $_"
}

Write-Host "[PS] Current environment variables:"
Get-ChildItem env: | ForEach-Object { "$($_.Name)=$($_.Value)" }
PS1
        echo "---- ps1file ----"
        cat "$ps1file"
        echo "---------------------------------------------"

        # Run the PowerShell script with expanded bash variables (so arch is literal)
        # Capture both stdout and stderr into the tmpfile for richer diagnostics.
        #powershell -NoProfile -File "$(cygpath -w "$ps1file")" -chosen "$(cygpath -w "$chosen")" -arch "$arch_bits" 2>&1 | tr -d '\r' > "$tmpfile"

        echo "[DEBUG] Running PowerShell script with:"
        echo "[DEBUG] ps1file: $(cygpath -w "$ps1file")"
        echo "[DEBUG] chosen: $(cygpath -w "$chosen")"
        echo "[DEBUG] arch_bits: $arch_bits"

        # Run the PowerShell script using -File (pass the PS1 path directly). Capture both stdout and stderr.
        echo "[DEBUG] PowerShell command about to execute..."
        runPowerShell -NoProfile -File "$ps1file" -chosen "$chosen" -arch "$arch_bits" 2>&1 | tee >(cat >&2) | tr -d '\r' > "$tmpfile" || true
        
        echo "[DEBUG] PowerShell execution completed"
        echo "[DEBUG] Checking tmpfile contents..."
        if [[ -f "$tmpfile" ]]; then
            echo "[DEBUG] tmpfile exists and has size: $(wc -c < "$tmpfile") bytes"
            echo "[DEBUG] First few lines of tmpfile:"
            head -n 5 "$tmpfile"
        else
            echo "[DEBUG] tmpfile does not exist!"
        fi

        # --- sanity check ---
        if [[ ! -s "$tmpfile" ]] || ! grep -qE '^PATH=' "$tmpfile"; then
            echo "Error: Visual Studio environment script ran but did not produce output (check $chosen)."
            # show partial output for debugging
            echo "---- raw vsenv output ----"
            if [[ -f "$tmpfile" ]]; then
                cat "$tmpfile"
            else
                echo "(no tmpfile created)"
            fi
            echo "---------------------------------------------"
            deleteFile "$ps1file"
            deleteFile "$tmpfile"
            return 1
        fi

        # --- import a safe whitelist of environment variables into bash ---
        echo "[DEBUG] Processing environment variables from tmpfile..."
        
        # First, let's see what we're working with
        echo "[DEBUG] Environment variables found in tmpfile:"
        grep -E '^(PATH|INCLUDE|LIB|LIBPATH|VSINSTALLDIR|VisualStudioVersion|VSCMD_ARG_TGT_ARCH|VSCMD_ARG_HOST_ARCH)=' "$tmpfile" || echo "No matching variables found!"
        
        while IFS='=' read -r name value; do
            case "$name" in
                PATH|INCLUDE|LIB|LIBPATH|VSINSTALLDIR|VisualStudioVersion|VSCMD_ARG_TGT_ARCH|VSCMD_ARG_HOST_ARCH)
                    echo "[DEBUG] Processing $name"
                    if [[ "$name" == "PATH" ]]; then
                        # Ensure Windows path separators and prepend VS paths
                        value="${value//\\/\/}"  # Replace backslashes with forward slashes
                        if [[ "$value" != *"Common7/IDE"* ]]; then
                            value="$(dirname "$chosen")/Common7/IDE:$value"
                        fi
                        echo "[DEBUG] Modified PATH value: $value"
                    fi
                    export "$name=$value"
                    echo "[DEBUG] Exported $name"
                    ;;
                *)
                    echo "[DEBUG] Skipping variable: $name"
                    ;;
            esac
        done < "$tmpfile"
        
        echo "[DEBUG] Environment variables processed"
        echo "[DEBUG] Final PATH: $PATH"

        # --- export CC/CXX ---
        export CC="cl.exe"
        export CXX="cl.exe"

        deleteFile "$ps1file"
        deleteFile "$tmpfile"

        # --- verify cl.exe in PATH ---
        if ! command -v cl.exe &>/dev/null; then
            echo "Error: MSVC environment loaded but cl.exe not found in PATH"
            echo "------------- PATH --------------------------"
            echo "C${PATH}"
            echo "---------------------------------------------"
            return 1
        fi

        echo "MSVC environment loaded successfully (arch=$arch_bits)."
        return 0
    }



elif [[ "$ENVIRONMENT" == "macOS" ]]; then
    echo ""
    echo "!!! THIS ENVIRONMENT IS NOT TESTED !!!"
    echo ""
    BREW_PREFIX="$(brew --prefix)"
    GCC_CPP_PATH="${BREW_PREFIX}/bin/g++-${GCC_VERSION}"
    GCC_C_PATH="${BREW_PREFIX}/bin/gcc-${GCC_VERSION}"
    CLANG_CPP_PATH="/usr/bin/clang++"  # macOS uses system clang
    CLANG_C_PATH="/usr/bin/clang"
    
    CLANG_FORMAT_PATH="${BREW_PREFIX}/bin/clang-format"
    CLANG_TIDY_PATH="${BREW_PREFIX}/bin/clang-tidy"
else
    # Linux/WSL/Windows-cygwin
    GCC_CPP_PATH="/usr/bin/g++-${GCC_VERSION}"
    GCC_C_PATH="/usr/bin/gcc-${GCC_VERSION}"
    CLANG_CPP_PATH="/usr/bin/clang++-${CLANG_VERSION}"
    CLANG_C_PATH="/usr/bin/clang-${CLANG_VERSION}"

    CLANG_FORMAT_PATH="/usr/bin/clang-format-${CLANG_FORMAT_VERSION}"
    CLANG_TIDY_PATH="/usr/bin/clang-tidy-${CLANG_TIDY_VERSION}"
fi


echo "Detected environment: $ENVIRONMENT on $ARCH-$ARCH_BITS"


