# .environment
# This file defines environment variables for compiler versions, paths, and tool versions.

# Detect architecture
ARCH=$(uname -m 2>/dev/null || echo "unknown")
case "$ARCH" in
    x86_64|amd64)
        ARCH_BITS="x64"
        ARCH="amd"
        ;;
    i386|i486|i586|i686)
        ARCH_BITS="x86"
        ARCH="amd"
        ;;
    arm64|aarch64)
        ARCH_BITS="x64"
        ARCH="arm"
        ;;
    armv7l|armv6l)
        ARCH_BITS="x86"
        ARCH="arm"
        ;;
    *)
        ARCH_BITS="unknown"
        ARCH="unknown"
        ;;
esac

# Detect environment
if grep -qi microsoft /proc/version 2>/dev/null; then
    ENVIRONMENT="WSL"
elif [[ "$OSTYPE" == "msys" ]]; then
    ENVIRONMENT="Windows-msys"
elif [[ "$OSTYPE" == "cygwin" ]]; then
    ENVIRONMENT="Windows-cygwin"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    ENVIRONMENT="Linux"
elif [[ "$OSTYPE" == "darwin"* ]]; then
    ENVIRONMENT="macOS"
else
    ENVIRONMENT="Unknown"
fi

# Common compiler versions
GCC_VERSION=13
CLANG_VERSION=19
MSVC_VERSION="2022"

DEFAULT_COMPILER="g++"

# Common tool versions
CLANG_FORMAT_VERSION=19
CLANG_TIDY_VERSION=19

# Set paths based on environment
if [[ "$ENVIRONMENT" == "Windows-msys" ]]; then
    # MSYS2 paths
    MINGW_GCC_BASE="C:/msys64/mingw64/bin"
    MINGW_32_GCC_BASE="C:/msys64/mingw32/bin"
    
    # Compiler paths
    GCC_CPP_PATH="${MINGW_GCC_BASE}/g++.exe"
    GCC_C_PATH="${MINGW_GCC_BASE}/gcc.exe"
    GCC_32_CPP_PATH="${MINGW_32_GCC_BASE}/g++.exe"
    GCC_32_C_PATH="${MINGW_32_GCC_BASE}/gcc.exe"

    CLANG_CPP_PATH="${MINGW_GCC_BASE}/clang++.exe"
    CLANG_C_PATH="${MINGW_GCC_BASE}/clang.exe"
    CLANG_32_CPP_PATH="${MINGW_32_GCC_BASE}/clang++.exe"
    CLANG_32_C_PATH="${MINGW_32_GCC_BASE}/clang.exe"

    # Tool paths
    CLANG_FORMAT_PATH="${MINGW_GCC_BASE}/clang-format.exe"
    CLANG_TIDY_PATH="${MINGW_GCC_BASE}/clang-tidy.exe"

    # Call this as: setup_msvc_env "<x86|x64>"
    function setup_msvc_env() {
        local arch_bits="$1"   # expected "x86" or "x64"
        local vswhere_path="" vs_base=""
        local tmpfile

        # find vswhere.exe (try PATH then common installers)
        vswhere_path=$(cmd.exe /C "where vswhere.exe" 2>/dev/null | tr -d '\r' || true)
        if [[ -z "$vswhere_path" || ! -f "$vswhere_path" ]]; then
            for p in \
                "C:/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe" \
                "C:/Program Files/Microsoft Visual Studio/Installer/vswhere.exe"
            do
                [[ -f "$p" ]] && vswhere_path="$p" && break
            done
        fi
        if [[ -z "$vswhere_path" || ! -f "$vswhere_path" ]]; then
            echo "Error: vswhere.exe not found on PATH or in common locations."
            return 1
        fi

        # get installation path
        vs_base=$(powershell -NoProfile -Command "& { & \"$vswhere_path\" -latest -products * -requires Microsoft.Component.MSBuild -property installationPath }" | tr -d '\r' | tail -n 1)

        if [[ -z "$vs_base" ]]; then
            echo "Error: Visual Studio installation not found via vswhere!"
            return 1
        fi
        echo "Found Visual Studio at: $vs_base"

        # candidate scripts (prefer VsDevCmd)
        local vsdev="${vs_base}/Common7/Tools/VsDevCmd.bat"
        local vcvarsall="${vs_base}/VC/Auxiliary/Build/vcvarsall.bat"
        local vcvars32="${vs_base}/VC/Auxiliary/Build/vcvars32.bat"
        local vcvars64="${vs_base}/VC/Auxiliary/Build/vcvars64.bat"
        local chosen=""

        # prefer VsDevCmd with -arch if available
        if [[ -f "$vsdev" ]]; then
            chosen="$vsdev"
            echo "Using VsDevCmd: $chosen"
        elif [[ -f "$vcvarsall" ]]; then
            chosen="$vcvarsall"
            echo "Using vcvarsall: $chosen"
        else
            # fallback to vcvars32/64
            if [[ "$arch_bits" == "x86" && -f "$vcvars32" ]]; then
                chosen="$vcvars32"
                echo "Using vcvars32: $chosen"
            elif [[ "$arch_bits" == "x64" && -f "$vcvars64" ]]; then
                chosen="$vcvars64"
                echo "Using vcvars64: $chosen"
            else
                # try a find search as final attempt
                chosen=$(find "$vs_base" -type f -iname "vcvars*.bat" 2>/dev/null | head -n 1 || true)
                if [[ -n "$chosen" ]]; then
                    echo "Found alternative vcvars script: $chosen"
                fi
            fi
        fi

        if [[ -z "$chosen" || ! -f "$chosen" ]]; then
            echo "Error: No suitable vcvars/VsDevCmd script found under $vs_base"
            return 1
        fi

        # create temp file to capture environment from cmd.exe
        tmpfile=$(mktemp) || tmpfile="/tmp/vsenv.$$"

        # Build the cmd invocation depending on chosen script
        local cmdline=""
        if [[ "$(basename "$chosen")" == "VsDevCmd.bat" ]]; then
            # VsDevCmd takes -arch argument
            if [[ "$arch_bits" == "x86" ]]; then
                cmdline="call \"${chosen}\" -arch=IA32 && set"
            else
                cmdline="call \"${chosen}\" -arch=AMD64 && set"
            fi
        elif [[ "$(basename "$chosen")" == "vcvarsall.bat" ]]; then
            # vcvarsall expects x86/x64 parameters
            if [[ "$arch_bits" == "x86" ]]; then
                cmdline="call \"${chosen}\" x86 && set"
            else
                cmdline="call \"${chosen}\" x64 && set"
            fi
        else
            # vcvars32.bat or vcvars64.bat (no extra args)
            cmdline="call \"${chosen}\" && set"
        fi

        echo "Using VsDevCmd: $chosen"
        local env_dump
        env_dump=$(cmd.exe /V:ON /E:ON /C "\"$chosen\" >nul && set" 2>/dev/null)

        if [[ -z "$env_dump" ]]; then
            echo "Error: Visual Studio environment script ran but did not produce output!"
            return 1
        fi

        # Convert CRLF to LF and extract relevant environment variables
        echo "$env_dump" | tr -d '\r' | \
        grep -E "^(INCLUDE|LIB|LIBPATH|PATH|VSINSTALLDIR|VisualStudioVersion|VSCMD_ARG_TGT_ARCH|VSCMD_ARG_HOST_ARCH)=" | \
        awk -F= '{print "export " $1 "=\"" $2 "\""}' > /tmp/msvc_env.sh

        if [[ ! -s /tmp/msvc_env.sh ]]; then
            echo "Error: Visual Studio environment script ran but did not populate environment (check $chosen)."
            return 1
        fi

        # Load environment into current bash session
        source /tmp/msvc_env.sh
        rm -f /tmp/msvc_env.sh

        # Export compiler tools
        export CC="cl.exe"
        export CXX="cl.exe"

        # Verify compiler
        if ! command -v cl.exe &>/dev/null; then
            echo "Error: MSVC environment loaded but cl.exe not found in PATH"
            echo "Current PATH (truncated):"
            echo "${PATH:0:400}"
            return 1
        fi

        echo "MSVC environment loaded successfully (arch=$arch_bits)."
        return 0
    }


elif [[ "$ENVIRONMENT" == "macOS" ]]; then
    echo ""
    echo "!!! THIS ENVIRONMENT IS NOT TESTED !!!"
    echo ""
    BREW_PREFIX="$(brew --prefix)"
    GCC_CPP_PATH="${BREW_PREFIX}/bin/g++-${GCC_VERSION}"
    GCC_C_PATH="${BREW_PREFIX}/bin/gcc-${GCC_VERSION}"
    CLANG_CPP_PATH="/usr/bin/clang++"  # macOS uses system clang
    CLANG_C_PATH="/usr/bin/clang"
    
    CLANG_FORMAT_PATH="${BREW_PREFIX}/bin/clang-format"
    CLANG_TIDY_PATH="${BREW_PREFIX}/bin/clang-tidy"
else
    # Linux/WSL/Windows-cygwin
    GCC_CPP_PATH="/usr/bin/g++-${GCC_VERSION}"
    GCC_C_PATH="/usr/bin/gcc-${GCC_VERSION}"
    CLANG_CPP_PATH="/usr/bin/clang++-${CLANG_VERSION}"
    CLANG_C_PATH="/usr/bin/clang-${CLANG_VERSION}"

    CLANG_FORMAT_PATH="/usr/bin/clang-format-${CLANG_FORMAT_VERSION}"
    CLANG_TIDY_PATH="/usr/bin/clang-tidy-${CLANG_TIDY_VERSION}"
fi


echo "Detected environment: $ENVIRONMENT on $ARCH-$ARCH_BITS"


